<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pending</title>
  <style>
    :root{
      --bg:#0b0b0b;
      --fg:#d0d0d0;
      --muted:#8a8a8a;
      --panel:#111;
      --border:#2a2a2a;
      --token-bg:#0f0f0f;
      --token-border:#3a3a3a;
      --ticker-h:22px;
      --header-h:92px;
      --action-h:72px;
      --pad:12px;
      --font: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }

    html, body{
      height:100%;
      margin:0;
      background:var(--bg);
      color:var(--fg);
      font-family:var(--font);
      overflow:hidden; /* keep it boxed-in */
    }

    /* Layout */
    #app{
      position:relative;
      height:100%;
      width:100%;
    }

    #header{
      position:fixed;
      top:0; left:0; right:0;
      height:var(--header-h);
      padding: var(--pad);
      box-sizing:border-box;
      background:linear-gradient(to bottom, rgba(0,0,0,0.95), rgba(0,0,0,0.70));
      border-bottom:1px solid var(--border);
      z-index: 30;
    }

    #titleRow{
      display:flex;
      align-items:baseline;
      justify-content:space-between;
      gap:10px;
      white-space:nowrap;
    }

    #title{
      font-size:16px;
      letter-spacing:0.3px;
      color:var(--muted);
    }

    #status{
      font-size:18px;
      font-weight:600;
      letter-spacing:0.2px;
      color:var(--fg);
    }

    #timer{
      font-size:13px;
      color:var(--muted);
      letter-spacing:0.2px;
    }

    #subRow{
      margin-top:8px;
      display:flex;
      justify-content:space-between;
      gap:10px;
      color:var(--muted);
      font-size:12px;
      line-height:1.3;
    }

    #subRow span{
      display:inline-block;
    }

    #messageArea{
      position:fixed;
      top:var(--header-h);
      left:0;
      right:0;
      bottom:calc(var(--ticker-h) + var(--action-h));
      padding: var(--pad);
      box-sizing:border-box;
      overflow:hidden; /* text can be obscured by tokens */
      z-index: 10;
      pointer-events:none; /* tokens will still be non-interactable; overall: no clicking */
    }

    #messages{
      font-size:13px;
      line-height:1.35;
      color:var(--fg);
      white-space:pre-wrap;
      word-break:break-word;
    }

    .msg{
      margin:0 0 8px 0;
      padding:0;
    }

    .msg.muted{
      color: var(--muted);
    }

    /* Token layer */
    #tokenLayer{
      position:fixed;
      top:var(--header-h);
      left:0;
      right:0;
      bottom:calc(var(--ticker-h) + var(--action-h));
      z-index: 20; /* above messages so it can occlude */
      pointer-events:none;
    }

    .token{
      position:absolute;
      width:120px;
      height:44px;
      padding:6px 8px;
      box-sizing:border-box;
      background:var(--token-bg);
      border:1px solid var(--token-border);
      color:var(--fg);
      font-size:12px;
      line-height:1.2;
      display:flex;
      align-items:center;
      justify-content:flex-start;
      user-select:none;
      filter:none;
      text-transform:none;
    }

    /* Action bar */
    #actionBar{
      position:fixed;
      left:0; right:0;
      bottom:var(--ticker-h);
      height:var(--action-h);
      border-top:1px solid var(--border);
      background:rgba(0,0,0,0.85);
      padding:10px var(--pad);
      box-sizing:border-box;
      z-index: 40;
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:14px;
    }

    #actions{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:flex-start;
    }

    .action{
      border:1px solid var(--border);
      background:var(--panel);
      padding:6px 10px;
      font-size:12px;
      color:var(--fg);
      min-width:120px;
      box-sizing:border-box;
    }

    .action.selected{
      outline:1px solid var(--muted);
    }

    #hint{
      font-size:12px;
      color:var(--muted);
      line-height:1.2;
      white-space:pre-wrap;
      text-align:right;
      max-width:40%;
    }

    /* Ticker */
    #ticker{
      position:fixed;
      left:0; right:0;
      bottom:0;
      height:var(--ticker-h);
      border-top:1px solid var(--border);
      background:#070707;
      z-index: 50;
      overflow:hidden;
    }

    #tickerTrack{
      position:absolute;
      left:0;
      top:0;
      height:100%;
      display:flex;
      align-items:center;
      gap:40px;
      white-space:nowrap;
      will-change:transform;
      animation: scroll 42s linear infinite;
      color:#6f6f6f; /* low contrast on purpose */
      font-size:12px;
      padding-left:100%;
    }

    @keyframes scroll{
      0%{ transform: translateX(0); }
      100%{ transform: translateX(-100%); }
    }

    /* Focus visibility for keyboard users (keep minimal, still accessible) */
    :focus{
      outline: 1px solid #777;
      outline-offset: 2px;
    }

    /* Reduce motion: keep ticker but slow it */
    @media (prefers-reduced-motion: reduce){
      #tickerTrack{ animation-duration: 120s; }
    }
  </style>
</head>
<body>
  <div id="app" aria-label="Pending system" role="application">
    <div id="header">
      <div id="titleRow">
        <div id="title" aria-hidden="true">Pending</div>
        <div id="status" aria-live="polite">Status: Pending</div>
        <div id="timer" aria-live="polite">10:00</div>
      </div>
      <div id="subRow">
        <span id="subLeft" aria-hidden="true">Requirements outstanding.</span>
        <span id="subRight" aria-hidden="true">Verification required.</span>
      </div>
    </div>

    <div id="messageArea" aria-label="Messages">
      <div id="messages" aria-live="polite"></div>
    </div>

    <div id="tokenLayer" aria-hidden="true"></div>

    <div id="actionBar" aria-label="Actions">
      <div id="actions" role="group" aria-label="Action choices">
        <div class="action selected" data-action="A" tabindex="0" aria-label="Action A">A — Acknowledge</div>
        <div class="action" data-action="B" tabindex="-1" aria-label="Action B">B — Submit</div>
        <div class="action" data-action="C" tabindex="-1" aria-label="Action C">C — Wait</div>
      </div>
      <div id="hint" aria-hidden="true">Keys: A/B/C · ? = Check status · ←/→ + Enter</div>
    </div>

    <div id="ticker" aria-hidden="true">
      <div id="tickerTrack"></div>
    </div>
  </div>

<script>
(() => {
  "use strict";

  // ---------- Config (static) ----------
  const DURATION_MS = 10 * 60 * 1000;

  const RESOLVE_PROBABILITY = 0.70; // approx 70% can resolve

  const TOKEN_TYPES = [
    { key: "verification", labels: ["Verified","Checked","Matched","Confirmed","Validated","Cross-checked"], roleHint: "verification" },
    { key: "authorization", labels: ["Approved","Authorised","Cleared","Signed","Released","Sanctioned"], roleHint: "authorization" },
    { key: "receipt", labels: ["Received","Recorded","Logged","Acknowledged","On file","Noted"], roleHint: "receipt" },
    { key: "processing", labels: ["In progress","Being processed","Under review","Pending action","Queued","Still processing"], roleHint: "processing" },
    { key: "transfer", labels: ["Referred","Forwarded","Transferred","Passed on","Handed over","Routed"], roleHint: "transfer" },
    { key: "exception", labels: ["On hold","Further review required","Query raised","Additional information required","Unable to complete","Pending clarification"], roleHint: "exception" }
  ];

  const TICKER_PHRASES = [
    "File being located…",
    "Status being reviewed…",
    "Awaiting confirmation…",
    "Request acknowledged…",
    "Processing update…",
    "Pending verification…",
    "Record matched…",
    "Still in progress…",
    "Routing request…",
    "Under review…",
    "Queued…",
    "Pending action…"
  ];

  const MESSAGE_BANK = [
    "Condition recorded.",
    "Further verification required.",
    "No action necessary at this time.",
    "This item is still being processed.",
    "Request acknowledged.",
    "Unable to confirm at this time.",
    "Record updated.",
    "Processing delay.",
    "Pending clarification.",
    "Status unchanged."
  ];

  const CHECK_MESSAGES = [
    "Status check recorded.",
    "Verification required.",
    "No update available.",
    "Awaiting confirmation.",
    "Record located.",
    "No further action at this time."
  ];

  const MEAN_CHECK_MESSAGE = "Please check whether you have received a letter.";

  // ---------- State ----------
  const state = {
    startedAt: performance.now(),
    endsAt: performance.now() + DURATION_MS,
    finished: false,
    status: "Pending",
    checksCount: 0,
    sessionCanResolve: (Math.random() < RESOLVE_PROBABILITY),
    required: new Map(),   // type -> count
    granted: new Map(),    // type -> count
    prompt: null,          // { kind, text, options: [{key,label}] }
    selectedActionIndex: 0
  };

  // DOM refs
  const elStatus = document.getElementById("status");
  const elTimer = document.getElementById("timer");
  const elMessages = document.getElementById("messages");
  const elTokenLayer = document.getElementById("tokenLayer");
  const actionEls = Array.from(document.querySelectorAll(".action"));
  const elHint = document.getElementById("hint");
  const elSubLeft = document.getElementById("subLeft");
  const elSubRight = document.getElementById("subRight");
  const elTickerTrack = document.getElementById("tickerTrack");

  // ---------- Helpers ----------
  const randInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
  const choice = (arr) => arr[Math.floor(Math.random() * arr.length)];
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

  function mmss(ms){
    const s = Math.max(0, Math.floor(ms / 1000));
    const m = Math.floor(s / 60);
    const r = s % 60;
    return String(m).padStart(2,"0") + ":" + String(r).padStart(2,"0");
  }

  function setStatus(text){
    state.status = text;
    elStatus.textContent = "Status: " + text;
  }

  function addMessage(text, muted=false){
    const p = document.createElement("div");
    p.className = "msg" + (muted ? " muted" : "");
    p.textContent = text;
    elMessages.prepend(p);

    // Cap message list to prevent DOM bloat; older messages vanish (also realistic)
    const MAX_MSG = 35;
    while(elMessages.childNodes.length > MAX_MSG){
      elMessages.removeChild(elMessages.lastChild);
    }
  }

  function tokenTypeDef(key){
    return TOKEN_TYPES.find(t => t.key === key);
  }

  function incMap(map, key, inc=1){
    map.set(key, (map.get(key) || 0) + inc);
  }

  function hasSatisfiedAllRequirements(){
    for(const [type, needed] of state.required.entries()){
      const have = state.granted.get(type) || 0;
      if(have < needed) return false;
    }
    return true;
  }

  // ---------- Requirements setup ----------
  function setupRequirements(){
    // Choose required token types and counts (hidden).
    // Keep it small, but not inferable.
    const baseRequired = ["verification", "authorization", "transfer"];
    baseRequired.forEach(k => state.required.set(k, randInt(1,2)));

    // In some sessions add a small extra requirement.
    if(Math.random() < 0.35) state.required.set("receipt", randInt(1,2));

    // For non-resolving sessions, add a blocking requirement that will never be granted.
    if(!state.sessionCanResolve){
      state.required.set("exception", 1);
    } else {
      // For resolving sessions, exception may still appear as noise, but is not required.
      // (No entry in required map.)
    }

    // Seed granted counts
    TOKEN_TYPES.forEach(t => state.granted.set(t.key, 0));
  }

  // ---------- Token rendering ----------
  function addToken(typeKey){
    const def = tokenTypeDef(typeKey);
    if(!def) return;

    // Increment internal counts
    incMap(state.granted, typeKey, 1);

    // Render visible "letter"
    const token = document.createElement("div");
    token.className = "token";
    token.textContent = choice(def.labels);

    // Random placement within token layer bounds
    const rect = elTokenLayer.getBoundingClientRect();
    const w = 120, h = 44;

    // keep within bounds, but allow overlap & mess
    const x = randInt(0, Math.max(0, Math.floor(rect.width - w)));
    const y = randInt(0, Math.max(0, Math.floor(rect.height - h)));

    token.style.left = x + "px";
    token.style.top = y + "px";

    // tiny rotation for messiness
    const rot = (Math.random() * 10 - 5); // -5..+5 degrees
    token.style.transform = "rotate(" + rot.toFixed(2) + "deg)";

    // z-index chaos
    token.style.zIndex = String(20 + randInt(0, 500));

    // Snap arrival: no animation, no transitions.
    elTokenLayer.appendChild(token);

    // Occasional extra clutter bursts
    if(Math.random() < 0.12){
      // add one extra noise token immediately (could be same type)
      const noiseType = choice(["processing","receipt","processing","transfer","processing"]);
      setTimeout(() => {
        if(!state.finished) addToken(noiseType);
      }, randInt(50, 250));
    }

    // After adding, check resolution
    if(state.sessionCanResolve && hasSatisfiedAllRequirements()){
      resolveNow();
    }
  }

  // ---------- Ticker setup ----------
  function setupTicker(){
    // Build a long loop by repeating phrases.
    const parts = [];
    const repeats = 36;
    for(let i=0;i<repeats;i++){
      parts.push(choice(TICKER_PHRASES));
    }
    elTickerTrack.textContent = parts.join("   •   ");
  }

  // ---------- Prompts ----------
  function setPrompt(prompt){
    state.prompt = prompt;
    // Update action bar UI to match prompt
    const opts = prompt.options;
    for(let i=0;i<actionEls.length;i++){
      const el = actionEls[i];
      const opt = opts[i];
      if(opt){
        el.style.display = "";
        el.dataset.action = opt.key;
        el.textContent = opt.key + " — " + opt.label;
      } else {
        el.style.display = "none";
      }
    }
    state.selectedActionIndex = 0;
    syncActionSelection();
    addMessage(prompt.text, true);
    // Update hint
    elHint.textContent = "Keys: " + opts.map(o => o.key).join("/") + " · ←/→ + Enter";
  }

  function clearPrompt(){
    state.prompt = null;
    // Restore default actions
    const defaults = [
      { key:"A", label:"Acknowledge" },
      { key:"B", label:"Submit" },
      { key:"C", label:"Wait" }
    ];
    for(let i=0;i<actionEls.length;i++){
      const el = actionEls[i];
      const d = defaults[i];
      el.style.display = "";
      el.dataset.action = d.key;
      el.textContent = d.key + " — " + d.label;
    }
    state.selectedActionIndex = 0;
    syncActionSelection();
    elHint.textContent = "Keys: A/B/C · ? = Check status · ←/→ + Enter";
  }

  function maybeAskConfirmationQuestion(){
    // Sometimes, after a check, ask a confirmation question.
    if(state.finished) return;
    if(state.prompt) return;
    if(Math.random() < 0.18){
      setPrompt({
        kind: "confirm_letter",
        text: "Have you received this letter?",
        options: [
          { key:"A", label:"Yes" },
          { key:"B", label:"No" }
        ]
      });
    }
  }

  // ---------- Actions ----------
  function handleCheck(){
    if(state.finished) return;
    if(state.prompt) return; // checking disabled during prompt; keep it tight
    state.checksCount++;

    // Sometimes mean message
    if(Math.random() < 0.10){
      addMessage(MEAN_CHECK_MESSAGE);
      // It still might grant a token, unrelated.
      if(Math.random() < 0.20){
        maybeGrantTokenFromCheck();
      }
      maybeAskConfirmationQuestion();
      return;
    }

    // Normal check behaviour
    const roll = Math.random();
    if(roll < 0.20){
      // do nothing
    } else if(roll < 0.72){
      addMessage(choice(CHECK_MESSAGES));
    } else {
      addMessage(choice(CHECK_MESSAGES));
      maybeGrantTokenFromCheck();
    }

    maybeAskConfirmationQuestion();
  }

  function maybeGrantTokenFromCheck(){
    // Checking may grant a token; not reliable; not correlated with requirements.
    const t = weightedTokenChoice({ fromCheck:true });
    if(t) addToken(t);
  }

  function handleAction(key){
    if(state.finished) return;

    // If in prompt mode, interpret as prompt response
    if(state.prompt){
      handlePromptResponse(key);
      return;
    }

    // Generic actions: decoupled cause/effect
    const roll = Math.random();

    // Sometimes action produces nothing
    if(roll < 0.18){
      return;
    }

    // Sometimes message only
    if(roll < 0.70){
      addMessage(choice(MESSAGE_BANK));
      // Rarely triggers delayed token
      if(Math.random() < 0.16){
        scheduleDelayedToken();
      }
      return;
    }

    // Sometimes both message and immediate token
    addMessage(choice(MESSAGE_BANK));
    const t = weightedTokenChoice({ fromAction:true, action:key });
    if(t) addToken(t);
  }

  function handlePromptResponse(key){
    // key is A or B in confirm_letter prompt
    if(!state.prompt) return;
    const kind = state.prompt.kind;
    clearPrompt();

    // Do not resolve uncertainty. Make responses arbitrary.
    const roll = Math.random();

    // Sometimes ignore response entirely
    if(roll < 0.25){
      addMessage("Response recorded.");
      return;
    }

    // Sometimes trigger an exception token (even in resolving sessions, as noise)
    if(roll < 0.45){
      addMessage("Further verification required.");
      // If non-resolving, exception is required and will never be granted.
      // So ONLY grant exception when sessionCanResolve is true (noise), or grant as noise if not required.
      if(state.sessionCanResolve){
        addToken("exception");
      } else {
        // In non-resolving sessions, avoid granting the blocking token that would permit exit.
        // (The required exception must remain unmet.)
        // Still grant other noise.
        addToken(choice(["processing","receipt","processing"]));
      }
      return;
    }

    // Sometimes grant a random token unrelated to the letter
    addMessage("Request acknowledged.");
    const t = weightedTokenChoice({ fromPrompt:true, answer:key });
    if(t) addToken(t);
  }

  function weightedTokenChoice(ctx){
    // Designed chaos:
    // - processing/receipt common
    // - transfer/verification/authorization appear sometimes
    // - exception appears as noise only when resolvable
    const pool = [];

    // Heavy noise
    for(let i=0;i<8;i++) pool.push("processing");
    for(let i=0;i<5;i++) pool.push("receipt");

    // Core-ish types
    for(let i=0;i<3;i++) pool.push("transfer");
    for(let i=0;i<2;i++) pool.push("verification");
    for(let i=0;i<2;i++) pool.push("authorization");

    // Exception as noise only if resolvable
    if(state.sessionCanResolve){
      if(Math.random() < 0.25) pool.push("exception");
    }

    // Occasionally bias towards required types when session can resolve
    if(state.sessionCanResolve && Math.random() < 0.25){
      // pick one required type with higher chance
      const reqTypes = Array.from(state.required.keys());
      const req = choice(reqTypes);
      if(req) pool.push(req, req, req);
    }

    // In non-resolving sessions, never grant the required exception token.
    // (But exception can still appear as messages via MESSAGE_BANK, and as "on hold" conceptually.)
    if(!state.sessionCanResolve){
      // Remove exception entries if any (defensive)
      for(let i=pool.length-1;i>=0;i--){
        if(pool[i] === "exception") pool.splice(i, 1);
      }
    }

    return choice(pool);
  }

  function scheduleDelayedToken(){
    // Delayed effects: appear after some time, unrelated to user action.
    const delay = randInt(900, 6500); // ms
    setTimeout(() => {
      if(state.finished) return;
      // 50/50: message only vs message + token
      if(Math.random() < 0.55){
        addMessage("Still being processed.");
      } else {
        addMessage("Record updated.");
        const t = weightedTokenChoice({ delayed:true });
        if(t) addToken(t);
      }
    }, delay);
  }

  // ---------- Resolution & timeout ----------
  function resolveNow(){
    if(state.finished) return;
    state.finished = true;
    setStatus("Complete");
    // Freeze UI without adding anything else
    elHint.textContent = "";
    // Stop updates
    teardown();
  }

  function timeoutNow(){
    if(state.finished) return;
    state.finished = true;
    setStatus("Pending");
    addMessage("You checked your status " + state.checksCount + " times.", true);
    // Reduce action UI to nothing
    actionEls.forEach(el => el.style.display = "none");
    elHint.textContent = "";
    teardown();
  }

  let timerHandle = null;
  let backgroundHandle = null;

  function teardown(){
    if(timerHandle) clearInterval(timerHandle);
    if(backgroundHandle) clearInterval(backgroundHandle);
    window.removeEventListener("keydown", onKeyDown, true);
  }

  // ---------- UI selection (arrows + enter) ----------
  function syncActionSelection(){
    actionEls.forEach((el, idx) => {
      const active = (idx === state.selectedActionIndex);
      el.classList.toggle("selected", active);
      el.tabIndex = active ? 0 : -1;
      if(active) el.focus({ preventScroll:true });
    });
  }

  function moveSelection(delta){
    const visible = actionEls.filter(el => el.style.display !== "none");
    if(visible.length === 0) return;
    state.selectedActionIndex = clamp(state.selectedActionIndex + delta, 0, visible.length - 1);
    // translate index within visible list
    actionEls.forEach(el => el.classList.remove("selected"));
    visible.forEach((el, idx) => {
      const active = (idx === state.selectedActionIndex);
      el.classList.toggle("selected", active);
      el.tabIndex = active ? 0 : -1;
      if(active) el.focus({ preventScroll:true });
    });
  }

  function activateSelected(){
    const visible = actionEls.filter(el => el.style.display !== "none");
    const el = visible[state.selectedActionIndex];
    if(!el) return;
    const key = el.dataset.action;
    if(key === "?"){
      handleCheck();
    } else {
      handleAction(key);
    }
  }

  // ---------- Keyboard handling ----------
  function onKeyDown(e){
    // Prevent browser navigation keys
    if(e.key === "Escape" || e.key === "Backspace"){
      e.preventDefault();
      e.stopPropagation();
      return;
    }

    if(state.finished){
      e.preventDefault();
      return;
    }

    // Check status
    if(e.key === "?"){
      e.preventDefault();
      handleCheck();
      return;
    }

    // Arrow selection
    if(e.key === "ArrowLeft"){
      e.preventDefault();
      moveSelection(-1);
      return;
    }
    if(e.key === "ArrowRight"){
      e.preventDefault();
      moveSelection(1);
      return;
    }
    if(e.key === "Enter"){
      e.preventDefault();
      activateSelected();
      return;
    }

    const k = e.key.toUpperCase();
    if(k === "A" || k === "B" || k === "C"){
      e.preventDefault();
      // Keep selection aligned with direct press
      // Map to visible options in prompt mode (A/B only)
      handleAction(k);
      return;
    }
  }

  // ---------- Background drift ----------
  function startBackgroundNoise(){
    // Periodically emit messages and tokens unrelated to action (illusion of backend).
    backgroundHandle = setInterval(() => {
      if(state.finished) return;

      // Occasionally inject a message
      if(Math.random() < 0.55){
        addMessage(choice(MESSAGE_BANK), Math.random() < 0.20);
      }

      // Occasionally add token; sometimes bursts so it can overwhelm screen
      if(Math.random() < 0.62){
        const t = weightedTokenChoice({ background:true });
        if(t) addToken(t);
      }

      // Rarely trigger an isolated "confirmation request" outside checks
      if(!state.prompt && Math.random() < 0.06){
        setPrompt({
          kind: "confirm_letter",
          text: "Have you received this letter?",
          options: [
            { key:"A", label:"Yes" },
            { key:"B", label:"No" }
          ]
        });
      }
    }, randInt(1400, 2400)); // jitter interval, changed below
  }

  // ---------- Timer ----------
  function startTimer(){
    timerHandle = setInterval(() => {
      const remaining = state.endsAt - performance.now();
      elTimer.textContent = mmss(remaining);
      if(remaining <= 0){
        timeoutNow();
      }
    }, 200);
  }

  // ---------- Initial screen ----------
  function seedScreen(){
    addMessage("Your status is pending.", true);
    addMessage("Outstanding conditions must be satisfied.", true);
    addMessage("Some conditions require your action.", true);
    addMessage("Others will be processed automatically.", true);

    // Some early clutter to establish tone
    const seedTokens = randInt(2, 6);
    for(let i=0;i<seedTokens;i++){
      // Early tokens should often be noise
      const t = choice(["processing","receipt","processing","transfer","receipt"]);
      addToken(t);
    }
  }

  // ---------- Init ----------
  function init(){
    setupRequirements();
    setupTicker();
    seedScreen();

    window.addEventListener("keydown", onKeyDown, true);

    startTimer();

    // Add ongoing background noise
    startBackgroundNoise();

    // Tiny drift in the header subtext so it feels "alive" but useless
    setInterval(() => {
      if(state.finished) return;
      elSubLeft.textContent = choice([
        "Requirements outstanding.",
        "Verification required.",
        "Pending confirmation.",
        "Processing delay.",
        "Status unchanged.",
        "Further review required."
      ]);
      elSubRight.textContent = choice([
        "Awaiting confirmation.",
        "Under review.",
        "Queued.",
        "Pending action.",
        "Record located.",
        "Routing request."
      ]);
    }, randInt(1800, 3200));
  }

  init();
})();
</script>
</body>
</html>
